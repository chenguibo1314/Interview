1、说说线程安全的几种实现方式？
答：
什么是线程安全？ 我的理解是这样的，一个对象被多个线程同时访问，还能保持其内部属性的顺序性及同步性，则认定为线程安全。实现线程安全的三种方式：被volatile、synchronized等关键字修饰，或者使用java.util.concurrent下面的类库。  至于前两者的关系，参考：synchronized和volatile的用法区别

2、方法内部，如何实现更好的异步？
答：
我们知道异步其实就是让另一个线程去跑，那么如何创建线程？  第一种直接new Thread ，第二种new 一个实现Runnable接口的实现类。 第三种，通过线程池来管理创建等 ，这里说到更好的实现异步，那就是说我们在方法内部避免频繁的new 线程，就可以考虑线程池了。 那么线程池如何创建？ 这里可以new 一个线程池，但是需要考虑单例，或者在程序初始启东时，就创建一个线程池，让他跑着，然后在具体方法的时候，通过线程池来创建线程，实现异步

3、多线程有什么用？
答：
1、发挥多核cpu的优势
2、防止阻塞
3、便于建模（大任务分解小任务，少了大任务的考虑，便于小任务的建模）

4、Runnable接口和Callable接口的区别
答：
1、Callable规定的方法是call()，并且有返回值；而Runnable规定的方法是run(),没有返回值
2、call()方法可抛出异常，而run()方法是不能抛出异常的
3、Callable接口可以通过FutureTask（异步运算任务）实现主线程阻塞
eg:FutureTask<String> task = new FutureTask<>(callable);
task.get();//直到返回结果继续执行

5、什么是线程死锁？死锁如何产生？如何避免线程死锁？
答：线程死锁就是指两个或者多个线程相互持有对方所需要的资源，导致等待状态，当线程进入对象的synchronized代码块时，便占有了资源，
直到退出或者wait方法才释放资源，如果两个线程都不释放对方所需要释放的资源，就会导致死锁。
如何避免：1、加锁顺序、2、加锁时限、3、死锁检测


